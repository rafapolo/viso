<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Viso / Despesas</title>
    <link href="https://fonts.googleapis.com/css2?family=Monda:wght@400;700&display=swap" rel="stylesheet">
    <link rel="shortcut icon" type="image/x-icon" href="https://extrapolo.com/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/+esm';
        
        let db;
        let conn;
        let connectionStatus = 'disconnected'; // 'disconnected', 'connecting', 'connected', 'error'
        
        function updateConnectionStatus(status, message = '') {
            connectionStatus = status;
            
            // Just log to console for debugging since UI elements are in db.html
            console.log(`🔌 Connection Status: ${status}${message ? ` - ${message}` : ''}`);
        }
        
        async function initDuckDB() {
            try {
                updateConnectionStatus('connecting', 'Inicializando DuckDB...');
                console.log('🚀 Initializing DuckDB...');
                
                // Check if DuckDB is already initialized
                if (db && conn) {
                    console.log('🔄 DuckDB already initialized, reusing connection');
                    updateConnectionStatus('connected', 'Já Conectado');
                    return { db, conn };
                }
                
                // Initialize DuckDB with timeout and better error handling
                updateConnectionStatus('connecting', 'Baixando DuckDB...');
                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
                
                updateConnectionStatus('connecting', 'Criando worker...');
                const worker = await duckdb.createWorker(bundle.mainWorker);
                const logger = new duckdb.ConsoleLogger();
                
                updateConnectionStatus('connecting', 'Instanciando DuckDB...');
                db = new duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                
                updateConnectionStatus('connecting', 'Estabelecendo conexão...');
                conn = await db.connect();
                
                // Test the connection with a simple query
                updateConnectionStatus('connecting', 'Testando conexão...');
                await conn.query('SELECT 1 as test');
                
                console.log('✅ DuckDB initialized and tested successfully');
                updateConnectionStatus('connected', 'Conectado e testado');
                
                return { db, conn };
            } catch (error) {
                console.error('❌ Error initializing DuckDB:', error);
                
                // Cleanup on error
                if (conn) {
                    try { await conn.close(); } catch (e) { console.warn('Error closing connection:', e); }
                    conn = null;
                }
                if (db) {
                    try { await db.terminate(); } catch (e) { console.warn('Error terminating DB:', e); }
                    db = null;
                }
                
                // Provide more specific error messages
                let errorMessage = 'Erro na Inicialização';
                if (error.message.includes('fetch')) {
                    errorMessage = 'Erro de rede';
                } else if (error.message.includes('worker')) {
                    errorMessage = 'Erro do worker';
                } else if (error.message.includes('instantiate')) {
                    errorMessage = 'Erro de instanciação';
                }
                
                updateConnectionStatus('error', errorMessage);
                throw error;
            }
        }
        
        async function loadParquetData() {
            try {
                updateConnectionStatus('connecting', 'Carregando dados...');
                console.log('📁 Loading parquet file into DuckDB...');
                
                // Fetch the parquet file as a blob
                const response = await fetch('./public/despesas.parquet');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                console.log(`📊 Downloaded ${(arrayBuffer.byteLength / 1024 / 1024).toFixed(1)} MB`);
                
                updateConnectionStatus('connecting', 'Processando dados...');
                
                // Register the file with DuckDB
                await db.registerFileBuffer('despesas.parquet', new Uint8Array(arrayBuffer));
                
                // Create a view from the registered parquet file
                await conn.query(`
                    CREATE VIEW despesas AS 
                    SELECT * FROM read_parquet('despesas.parquet')
                `);
                
                // Get total count
                const countResult = await conn.query("SELECT COUNT(*) as total FROM despesas");
                const totalRecords = countResult.toArray()[0].total;
                console.log(`✅ Loaded ${totalRecords.toLocaleString()} records from parquet`);
                
                updateConnectionStatus('connected', `${totalRecords.toLocaleString()} registros`);
                return totalRecords;
                
            } catch (error) {
                console.error('❌ Error loading parquet:', error);
                updateConnectionStatus('error', 'Erro ao carregar dados');
                throw error;
            }
        }
        
        async function checkConnectionHealth() {
            try {
                if (!conn) return false;
                
                // Try a simple query to test connection
                await conn.query("SELECT 1 as test");
                return true;
            } catch (error) {
                console.warn('Connection health check failed:', error);
                return false;
            }
        }
        
        async function ensureConnection() {
            try {
                const isHealthy = await checkConnectionHealth();
                
                if (!isHealthy) {
                    updateConnectionStatus('connecting', 'Reconectando...');
                    console.log('🔄 Connection lost, attempting to reconnect...');
                    
                    // Close existing connection if it exists
                    if (conn) {
                        try {
                            await conn.close();
                        } catch (e) {
                            console.warn('Error closing existing connection:', e);
                        }
                        conn = null;
                    }
                    
                    // Try to reconnect
                    if (db) {
                        conn = await db.connect();
                        
                        // Test the new connection
                        await conn.query("SELECT 1 as test");
                        
                        updateConnectionStatus('connected', 'Reconectado');
                        console.log('✅ Reconnected successfully');
                        return true;
                    } else {
                        // DB instance is gone, need full reinitialization
                        console.log('🔄 DB instance lost, reinitializing...');
                        await initDuckDB();
                        await loadParquetData();
                        return true;
                    }
                }
                
                return true;
            } catch (error) {
                console.error('❌ Connection recovery failed:', error);
                updateConnectionStatus('error', 'Falha na reconexão');
                throw new Error(`Connection recovery failed: ${error.message}`);
            }
        }
        
        async function queryAggregatedData(minValue = 0, partyFilter = '', categoryFilter = '', searchFilter = '') {
            await ensureConnection();
            console.log('🔍 Querying aggregated data...');
            
            let whereClause = "WHERE nome_parlamentar IS NOT NULL AND fornecedor IS NOT NULL";
            
            if (minValue > 0) {
                whereClause += ` AND valor_liquido >= ${minValue}`;
            }
            
            if (partyFilter) {
                whereClause += ` AND sigla_partido = '${partyFilter}'`;
            }
            
            if (categoryFilter) {
                whereClause += ` AND categoria_despesa = '${categoryFilter}'`;
            }
            
            if (searchFilter) {
                whereClause += ` AND (LOWER(nome_parlamentar) LIKE '%${searchFilter.toLowerCase()}%' OR LOWER(fornecedor) LIKE '%${searchFilter.toLowerCase()}%')`;
            }
            
            const query = `
                SELECT 
                    nome_parlamentar,
                    sigla_partido,
                    fornecedor,
                    categoria_despesa,
                    SUM(valor_liquido) as valor_total,
                    COUNT(*) as num_transacoes
                FROM despesas 
                ${whereClause}
                GROUP BY nome_parlamentar, sigla_partido, fornecedor, categoria_despesa
                HAVING SUM(valor_liquido) > 1000
                ORDER BY valor_total DESC
                LIMIT 10000
            `;
            
            console.log('📊 Executing query:', query);
            const result = await conn.query(query);
            const data = result.toArray();
            
            console.log(`✅ Query returned ${data.length} aggregated records`);
            return data;
        }
        
        async function getValueRange(partyFilter = '', categoryFilter = '', searchFilter = '') {
            await ensureConnection();
            console.log('🔍 Querying value range...');
            
            let whereClause = "WHERE nome_parlamentar IS NOT NULL AND fornecedor IS NOT NULL";
            
            if (partyFilter) {
                whereClause += ` AND sigla_partido = '${partyFilter}'`;
            }
            
            if (categoryFilter) {
                whereClause += ` AND categoria_despesa = '${categoryFilter}'`;
            }
            
            if (searchFilter) {
                whereClause += ` AND (LOWER(nome_parlamentar) LIKE '%${searchFilter.toLowerCase()}%' OR LOWER(fornecedor) LIKE '%${searchFilter.toLowerCase()}%')`;
            }
            
            const query = `
                SELECT 
                    MIN(valor_liquido) as min_valor,
                    MAX(valor_liquido) as max_valor
                FROM despesas 
                ${whereClause}
            `;
            
            console.log('📊 Executing value range query:', query);
            const result = await conn.query(query);
            const data = result.toArray();
            
            if (data.length > 0 && data[0].min_valor !== null) {
                return {
                    min: Math.max(0, Number(data[0].min_valor)) || 0,
                    max: Number(data[0].max_valor)
                };
            }
            
            return { min: 0, max: 100000 };
        }
        
        async function getFilterOptions() {
            await ensureConnection();
            console.log('🔍 Getting filter options...');
            
            // Get unique parties
            const partiesResult = await conn.query(`
                SELECT DISTINCT sigla_partido 
                FROM despesas 
                WHERE sigla_partido IS NOT NULL 
                ORDER BY sigla_partido
            `);
            const parties = partiesResult.toArray().map(r => r.sigla_partido);
            
            // Get unique categories
            const categoriesResult = await conn.query(`
                SELECT DISTINCT categoria_despesa 
                FROM despesas 
                WHERE categoria_despesa IS NOT NULL 
                ORDER BY categoria_despesa
            `);
            const categories = categoriesResult.toArray().map(r => r.categoria_despesa);
            
            return { parties, categories };
        }
        
        // Make functions globally available
        // Add cleanup on page unload
        window.addEventListener('beforeunload', () => {
            stopConnectionMonitoring();
        });
        
        // Make connection status functions globally accessible
        window.updateConnectionStatus = updateConnectionStatus;
        window.getConnectionStatus = () => connectionStatus;
        
        window.duckdbAPI = {
            initDuckDB,
            loadParquetData,
            queryAggregatedData,
            getValueRange,
            getFilterOptions,
            query: async (sql) => {
                await ensureConnection();
                return conn.query(sql);
            },
            getConnectionStatus: () => connectionStatus,
            ensureConnection
        };
        
    </script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'deputy': '#3b82f6',
                        'supplier': 'rgb(196, 82, 17)',
                        'duckdb': {
                            50: '#fffbeb',
                            100: '#fef3c7',
                            200: '#fde68a',
                            300: '#fcd34d',
                            400: '#fbbf24', 
                            500: '#FFC000', // DuckDB yellow
                            600: '#d97706',
                            700: '#b45309',
                            800: '#92400e',
                            900: '#78350f'
                        }
                    },
                    fontFamily: {
                        'sans': ['Monda', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style>
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #374151;
            border-radius: 50%;
            border-top-color: #FFC000;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Range Slider Styles */
        .slider-track {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .slider-track::-webkit-slider-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 4px;
        }

        .dark .slider-track::-webkit-slider-track {
            background: #374151;
        }

        .slider-track::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #FFC000;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .dark .slider-track::-webkit-slider-thumb {
            border-color: #1f2937;
        }

        .slider-track::-moz-range-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 4px;
            border: none;
        }

        .dark .slider-track::-moz-range-track {
            background: #374151;
        }

        .slider-track::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #FFC000;
            cursor: pointer;
            border: 2px solid #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .dark .slider-track::-moz-range-thumb {
            border-color: #1f2937;
        }
        
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FFC000;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FFC000;
            cursor: pointer;
            border: none;
        }
        
        /* Full screen layout */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        
        .sidebar-header {
            text-align: center;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .legend-items {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        #node-info-content {
            display: none;
            padding-top: 12px;
            border-top: 1px solid rgba(75, 85, 99, 0.3);
            margin-top: 12px;
        }
        
        /* Enhanced scrollbar styles */
        .enhanced-scroll {
            scrollbar-width: thin;
            scrollbar-color: #6B7280 #374151;
        }
        
        .enhanced-scroll::-webkit-scrollbar {
            width: 8px;
        }
        
        .enhanced-scroll::-webkit-scrollbar-track {
            background: #374151;
            border-radius: 4px;
        }
        
        .enhanced-scroll::-webkit-scrollbar-thumb {
            background: #6B7280;
            border-radius: 4px;
        }
        
        .enhanced-scroll::-webkit-scrollbar-thumb:hover {
            background: #9CA3AF;
        }
        
        /* Transaction card enhancements */
        .transaction-card {
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        
        .transaction-card:hover {
            transform: translateY(-1px);
        }
        
        /* Responsive card spacing */
        @media (max-width: 640px) {
            .transaction-card {
                padding: 0.75rem;
            }
        }
        
        /* Smooth scroll behavior */
        .smooth-scroll {
            scroll-behavior: smooth;
        }
        
        /* Force proper scrolling on node info panel */
        .node-info-scroll-container {
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 4px 0;
            max-height: calc(100vh - 200px);
        }
        
        /* Ensure right panel has proper height calculations */
        #right-panel {
            max-height: 100vh;
        }
        
        #node-info-section {
            max-height: calc(100vh - 60px); /* Account for header */
        }
    </style>
</head>
<body class="font-sans bg-white dark:bg-gray-950 text-gray-900 dark:text-white h-screen overflow-hidden">
    <div class="flex h-screen">
        <!-- Sidebar -->
        <div class="w-80 bg-gray-100 dark:bg-gray-900 border-r border-gray-300 dark:border-gray-700 flex flex-col">
            <div class="p-4 border-b border-gray-300 dark:border-gray-700 flex items-center gap-3">
                <div class="w-6 h-6 bg-duckdb-500 rounded flex items-center justify-center font-bold text-black text-sm">
                    📊
                </div>
                <div class="text-base font-semibold">Viso UI</div>
                <button onclick="window.location.href='db.html'" class="ml-auto px-3 py-1.5 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white rounded-lg text-xs font-medium transition-all duration-200 transform hover:scale-105 flex items-center gap-2">
                    <span>🗄️</span>
                    <span>Viso DB</span>
                </button>
                <button id="theme-toggle" class="p-1 rounded hover:bg-gray-200 dark:hover:bg-gray-800">
                    🌙
                </button>
            </div>
            
            <div class="p-4 border-b border-gray-300 dark:border-gray-700">
                <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-2">Legenda</div>
                <div class="legend-items">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-deputy"></div>
                        <span class="text-gray-600 dark:text-gray-300 text-xs">Deputados</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-supplier"></div>
                        <span class="text-gray-600 dark:text-gray-300 text-xs">Empresas</span>
                    </div>
                </div>
            </div>
            
            <div class="p-4 border-b border-gray-300 dark:border-gray-700">
                <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-2">Busca</div>
                <div class="relative">
                    <input 
                        type="text" 
                        id="searchBox" 
                        placeholder="Buscar deputado ou empresa..." 
                        class="w-full px-3 py-2 text-xs bg-white dark:bg-gray-800 text-gray-900 dark:text-white border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:border-duckdb-500 focus:ring-1 focus:ring-duckdb-500"
                    >
                    <button id="clearSearch" class="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-700 dark:hover:text-white text-sm hidden">
                        ✕
                    </button>
                </div>
            </div>
            
            <div class="p-4 border-b border-gray-300 dark:border-gray-700">
                <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-2">Filtros</div>
                <div class="space-y-3">
                    <div>
                        <label for="partyFilter" class="text-xs text-gray-600 dark:text-gray-300 mb-1 block">Partido:</label>
                        <select id="partyFilter" class="w-full px-2 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white">
                            <option value="">Todos os Partidos</option>
                        </select>
                    </div>
                    <div>
                        <label for="categoryFilter" class="text-xs text-gray-600 dark:text-gray-300 mb-1 block">Categoria:</label>
                        <select id="categoryFilter" class="w-full px-2 py-1 text-xs border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white">
                            <option value="">Todas as Categorias</option>
                        </select>
                    </div>
                    <div>
                        <div class="flex items-center justify-between text-xs text-gray-500 dark:text-gray-400 mb-1">
                            <span id="minRange">Min: R$ 0</span>
                            <span id="maxRange">Max: R$ 0</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <span class="text-duckdb-500 font-bold text-xs min-w-12" id="minValueValue">0</span>
                            <input type="range" id="minValue" class="slider-track flex-1 h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer" min="0" max="100000" value="0" step="500">
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Network Analysis Controls -->
            <div class="p-4 border-b border-gray-200 dark:border-gray-700">
                <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-3">Análise de Rede</div>
                <div class="space-y-2">
                    <div class="flex items-center justify-between py-1">
                        <label for="showCompanyNames" class="text-xs text-gray-600 dark:text-gray-300 flex items-center gap-2">
                            <span>🏢</span>
                            <span>Exibir nome das Empresas</span>
                        </label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="showCompanyNames" class="sr-only peer">
                            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <div class="flex items-center justify-between py-1">
                        <label for="showEdgeAmounts" class="text-xs text-gray-600 dark:text-gray-300 flex items-center gap-2">
                            <span>💳</span>
                            <span>Mostrar gasto</span>
                        </label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="showEdgeAmounts" class="sr-only peer">
                            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                    </div>                        
                    <div class="flex items-center justify-between py-1">
                        <label for="networkDensityToggle" class="text-xs text-gray-600 dark:text-gray-300 flex items-center gap-2">
                            <span>🔗</span>
                            <span>Rede mais Densa</span>
                        </label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="networkDensityToggle" class="sr-only peer" data-active="false">
                            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <div class="flex items-center justify-between py-1">
                        <label for="topExpensesToggle" class="text-xs text-gray-600 dark:text-gray-300 flex items-center gap-2">
                            <span>💰</span>
                            <span>Top 15 Gastos</span>
                        </label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="topExpensesToggle" class="sr-only peer" data-active="false">
                            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                </div>
            </div>

            <div class="p-4 border-b border-gray-300 dark:border-gray-700">
                <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-2">Estatísticas</div>
                <div class="stats-grid text-sm" id="stats">
                    <div class="bg-gray-200 dark:bg-gray-800 rounded p-3 border-l-2 border-supplier">
                        <div class="text-sm font-semibold text-supplier" id="totalDeputados">-</div>
                        <div class="text-gray-500 dark:text-gray-400 text-2xs">Deputados</div>
                    </div>
                    <div class="bg-gray-200 dark:bg-gray-800 rounded p-3 border-l-2 border-supplier">
                        <div class="text-sm font-semibold text-supplier" id="totalFornecedores">-</div>
                        <div class="text-gray-500 dark:text-gray-400 text-2xs">Empresas</div>
                    </div>
                    <div class="bg-gray-200 dark:bg-gray-800 rounded p-3 border-l-2 border-supplier">
                        <div class="text-sm font-semibold text-supplier" id="totalValue">-</div>
                        <div class="text-gray-500 dark:text-gray-400 text-2xs">Total (R$)</div>
                    </div>
                    <div class="bg-gray-200 dark:bg-gray-800 rounded p-3 border-l-2 border-supplier">
                        <div class="text-sm font-semibold text-supplier" id="totalTransactions">-</div>
                        <div class="text-gray-500 dark:text-gray-400 text-2xs">Transações</div>
                    </div>
                </div>
            </div>        
            
            <div class="p-4 flex-1 overflow-y-auto space-y-4">

                <!-- Category Pie Chart -->
                <div class="flex-1 flex flex-col min-h-0">
                    <div class="text-xs font-semibold text-gray-500 dark:text-gray-400 uppercase tracking-wide mb-3">Categorias</div>
                    <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-3 flex-1 flex flex-col min-h-0">
                        <div class="flex-shrink-0 flex justify-center items-center">
                            <canvas id="categoryPieChart" width="200" height="200" style="max-width: 100%; height: auto;"></canvas>
                        </div>
                        <div id="categoryLegend" class="mt-3 space-y-1 flex-1 overflow-y-auto text-xs enhanced-scroll"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col relative">
            <!-- Visualization -->
            <div id="visualization" class="flex-1 relative overflow-hidden" style="background-color: #0f1419;">
                <svg id="network-svg" class="w-full h-full cursor-grab"></svg>
                <div id="loading" class="absolute inset-0 flex flex-col justify-center items-center text-duckdb-500 text-lg">
                    <div class="loading-spinner mb-3"></div>
                    <div>Inicializando Viso UI...</div>
                    <div id="loadingProgress" class="text-sm text-gray-400 mt-2"></div>
                </div>
                
                <!-- Zoom controls -->
                <div class="absolute top-4 right-4 flex flex-col gap-2">
                    <button id="zoom-in" class="bg-gray-800 hover:bg-gray-700 text-white w-8 h-8 rounded flex items-center justify-center text-lg font-bold">+</button>
                    <button id="zoom-out" class="bg-gray-800 hover:bg-gray-700 text-white w-8 h-8 rounded flex items-center justify-center text-lg font-bold">−</button>
                    <button id="zoom-reset" class="bg-gray-800 hover:bg-gray-700 text-white w-8 h-8 rounded flex items-center justify-center text-xs font-bold">⌂</button>
                </div>
                <!-- Instructions -->
                <div class="absolute bottom-2 left-2 text-xs text-gray-400">
                    Wheel: zoom • Drag: pan • Click nodes: info
                </div>
            </div>
            
            <!-- Right Sidebar (Entity Panel) -->
            <div id="right-panel" class="absolute top-0 right-0 w-80 h-full bg-gray-100 dark:bg-gray-900 border-l border-gray-300 dark:border-gray-700 flex flex-col transform translate-x-full transition-transform duration-300 ease-in-out z-10 shadow-lg">
            <div class="p-4 border-b border-gray-300 dark:border-gray-700">
                <div class="flex justify-between items-center">
                    <div class="text-sm font-semibold text-gray-900 dark:text-white">Painel da Entidade</div>
                    <button id="close-panel" class="text-gray-400 hover:text-gray-900 dark:hover:text-white text-lg font-bold hidden">&times;</button>
                </div>
            </div>
            
            <div class="flex-1 flex flex-col min-h-0" id="node-info-section">
                <div class="p-4 flex flex-col flex-1 min-h-0" id="node-info-content">
                    <p class="text-xs text-gray-500 dark:text-gray-400">Clique em um nó para ver detalhes</p>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let processedData = { nodes: [], links: [] };
        let networkFilters = {
            densityMode: false,
            topExpensesMode: false
        };
        
        // Initialize DuckDB and load data
        async function loadData() {
            try {
                const progressEl = document.getElementById('loadingProgress');
                
                progressEl.textContent = 'Inicializando DuckDB...';
                await window.duckdbAPI.initDuckDB();
                
                progressEl.textContent = 'Carregando arquivo parquet...';
                const totalRecords = await window.duckdbAPI.loadParquetData();
                
                progressEl.textContent = 'Configurando filtros...';
                await populateFilters();
                
                progressEl.textContent = 'Processando dados...';
                await updateVisualization();
                
                setupEventListeners();
                startConnectionMonitoring();
                
            } catch (error) {
                console.error('❌ Erro:', error);
                updateConnectionStatus('error', 'Erro de inicialização');
                document.getElementById('loading').innerHTML = `
                    <div class="text-red-400">
                        <div class="text-lg mb-2">❌ Erro de Conexão</div>
                        <div class="text-sm">${error.message}</div>
                        <button onclick="location.reload()" class="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg">
                            🔄 Tentar Novamente
                        </button>
                    </div>
                `;
            }
        }
        
        // Periodic connection health check
        let healthCheckInterval;
        
        function startConnectionMonitoring() {
            // Check connection health every 30 seconds
            healthCheckInterval = setInterval(async () => {
                if (connectionStatus === 'connected') {
                    const isHealthy = await checkConnectionHealth();
                    if (!isHealthy) {
                        console.warn('🔴 Connection lost during health check');
                        updateConnectionStatus('error', 'Conexão perdida');
                    }
                }
            }, 30000);
        }
        
        function stopConnectionMonitoring() {
            if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
                healthCheckInterval = null;
            }
        }
        
        async function populateFilters() {
            const { parties, categories } = await window.duckdbAPI.getFilterOptions();
            
            const partySelect = document.getElementById('partyFilter');
            parties.forEach(party => {
                const option = document.createElement('option');
                option.value = party;
                option.textContent = party;
                if (party === 'PT') {
                    option.selected = true;
                }
                partySelect.appendChild(option);
            });
            
            const categorySelect = document.getElementById('categoryFilter');
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category.length > 50 ? category.substring(0, 47) + '...' : category;
                categorySelect.appendChild(option);
            });
        }
        
        async function processData() {
            const minValue = parseFloat(document.getElementById('minValue').value) || 0;
            const partyFilter = document.getElementById('partyFilter').value;
            const categoryFilter = document.getElementById('categoryFilter').value;
            const searchFilter = document.getElementById('searchBox').value.trim();
            
            console.log(`🔍 Filters - minValue: ${minValue}, party: ${partyFilter}, category: ${categoryFilter}, search: ${searchFilter}`);
            
            // Get the individual transaction value range (not aggregated sums)
            const valueRange = await window.duckdbAPI.getValueRange(partyFilter, categoryFilter, searchFilter);
            const minVal = valueRange.min;
            const maxVal = valueRange.max;
            
            // Update min/max range based on individual transaction values
            if (minVal !== null && maxVal !== null && maxVal > minVal) {
                
                // Update slider range to reflect actual data range
                const slider = document.getElementById('minValue');
                const currentValue = parseInt(slider.value);
                
                // Set slider bounds to actual data range
                // Ensure we have a reasonable range even if min and max are very close
                const rangeMin = Math.max(0, Math.floor(minVal)) || 0;
                const rangeMax = Math.max(Math.ceil(maxVal), rangeMin + 1000); // Ensure at least 1000 range
                
                slider.min = rangeMin;
                slider.max = rangeMax;
                
                // If current slider value is outside the new range, adjust it
                if (currentValue < rangeMin || currentValue > rangeMax) {
                    slider.value = rangeMin;
                }
                
                // Update range display to show the actual range of available data
                const formatCurrency = (value) => `R$ ${value.toLocaleString('pt-BR')}`;
                document.getElementById('minRange').textContent = `Min: ${formatCurrency(minVal)}`;
                document.getElementById('maxRange').textContent = `Max: ${formatCurrency(maxVal)}`;
                
                // Update the current value display with the corrected slider value
                const actualMinValue = parseFloat(slider.value) || 0;
                const minValueDisplay = document.getElementById('minValueValue');
                const formatValue = (val) => {
                    if (val >= 1000000) return `${(val/1000000).toFixed(1)}M`;
                    if (val >= 1000) return `${(val/1000).toFixed(0)}K`;
                    return val.toLocaleString('pt-BR');
                };
                minValueDisplay.textContent = formatValue(actualMinValue);
                
                console.log(`📊 Range updated: min=${rangeMin}, max=${rangeMax}, current=${actualMinValue}`);
            } else {
                // No data available - reset to defaults
                const slider = document.getElementById('minValue');
                slider.min = 0;
                slider.max = 100000;
                slider.value = 0;
                document.getElementById('minRange').textContent = 'Min: R$ 0';
                document.getElementById('maxRange').textContent = 'Max: R$ 100.000';
                document.getElementById('minValueValue').textContent = '0';
            }
            
            // Query DuckDB with all filters including the current minimum value
            const actualMinValue = parseFloat(document.getElementById('minValue').value) || 0;
            let aggregatedData = await window.duckdbAPI.queryAggregatedData(actualMinValue, partyFilter, categoryFilter, searchFilter);
            
            // If search filter exists, filter to show only relations of the searched entity
            if (searchFilter) {
                const searchLower = searchFilter.toLowerCase();
                const matchingEntities = new Set();
                
                // Find all entities that match the search term
                aggregatedData.forEach(record => {
                    const deputado = `${record.nome_parlamentar} (${record.sigla_partido})`;
                    const fornecedor = record.fornecedor;
                    
                    if (deputado.toLowerCase().includes(searchLower)) {
                        matchingEntities.add(deputado);
                    }
                    if (fornecedor.toLowerCase().includes(searchLower)) {
                        matchingEntities.add(fornecedor);
                    }
                });
                
                // If we found matching entities, filter to show only their relations
                if (matchingEntities.size > 0) {
                    aggregatedData = aggregatedData.filter(record => {
                        const deputado = `${record.nome_parlamentar} (${record.sigla_partido})`;
                        const fornecedor = record.fornecedor;
                        
                        // Show this record if either the deputado or fornecedor is in our matching entities
                        return matchingEntities.has(deputado) || matchingEntities.has(fornecedor);
                    });
                }
            }
            
            // Create nodes and links with totals
            const nodeMap = new Map();
            const nodeTotals = new Map();
            const nodes = [];
            const links = [];
            
            let nodeId = 0;
            
            // First pass: collect totals for each node
            aggregatedData.forEach(record => {
                const deputado = `${record.nome_parlamentar} (${record.sigla_partido})`;
                const fornecedor = record.fornecedor;
                
                // Track deputado totals
                if (!nodeTotals.has(deputado)) {
                    nodeTotals.set(deputado, { 
                        total: 0, 
                        transactions: 0, 
                        connections: 0,
                        type: 'deputado',
                        party: record.sigla_partido 
                    });
                }
                const deputadoTotals = nodeTotals.get(deputado);
                deputadoTotals.total += Number(record.valor_total);
                deputadoTotals.transactions += Number(record.num_transacoes);
                deputadoTotals.connections += 1;
                
                // Track fornecedor totals
                if (!nodeTotals.has(fornecedor)) {
                    nodeTotals.set(fornecedor, { 
                        total: 0, 
                        transactions: 0, 
                        connections: 0,
                        type: 'fornecedor' 
                    });
                }
                const fornecedorTotals = nodeTotals.get(fornecedor);
                fornecedorTotals.total += Number(record.valor_total);
                fornecedorTotals.transactions += Number(record.num_transacoes);
                fornecedorTotals.connections += 1;
            });
            
            // Second pass: create nodes and links
            aggregatedData.forEach(record => {
                const deputado = `${record.nome_parlamentar} (${record.sigla_partido})`;
                const fornecedor = record.fornecedor;
                
                // Add deputado node
                if (!nodeMap.has(deputado)) {
                    const totals = nodeTotals.get(deputado);
                    nodeMap.set(deputado, nodeId);
                    nodes.push({
                        id: nodeId.toString(),
                        label: deputado,
                        type: 'deputado',
                        party: record.sigla_partido,
                        totalValue: totals.total,
                        totalTransactions: totals.transactions,
                        totalConnections: totals.connections,
                        size: Math.log(totals.total) * 2
                    });
                    nodeId++;
                }
                
                // Add fornecedor node
                if (!nodeMap.has(fornecedor)) {
                    const totals = nodeTotals.get(fornecedor);
                    nodeMap.set(fornecedor, nodeId);
                    nodes.push({
                        id: nodeId.toString(),
                        label: fornecedor,
                        type: 'fornecedor',
                        totalValue: totals.total,
                        totalTransactions: totals.transactions,
                        totalConnections: totals.connections,
                        size: Math.log(totals.total) * 1.5
                    });
                    nodeId++;
                }
                
                // Add link
                links.push({
                    source: nodeMap.get(deputado).toString(),
                    target: nodeMap.get(fornecedor).toString(),
                    value: Number(record.valor_total),
                    count: Number(record.num_transacoes),
                    width: Math.max(1, Math.log(Number(record.valor_total)) * 0.5)
                });
            });
            
            processedData = { nodes, links };
            
            // Update stats
            const deputados = new Set(aggregatedData.map(r => `${r.nome_parlamentar} (${r.sigla_partido})`));
            const fornecedores = new Set(aggregatedData.map(r => r.fornecedor));
            const totalValue = aggregatedData.reduce((sum, r) => sum + Number(r.valor_total), 0);
            const totalTransactions = aggregatedData.reduce((sum, r) => sum + Number(r.num_transacoes), 0);
            
            document.getElementById('totalDeputados').textContent = deputados.size;
            document.getElementById('totalFornecedores').textContent = fornecedores.size;
            document.getElementById('totalValue').textContent = `${totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
            document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString();
            
            // Update category pie chart
            createCategoryPieChart(aggregatedData);
            
            // Store aggregatedData for network filtering stats
            window.currentAggregatedData = aggregatedData;
            
            console.log(`Processados ${nodes.length} nós e ${links.length} links`);
        }
        
        function applyNetworkFilters() {
            if (!processedData.nodes || !processedData.links) return processedData;
            
            let filteredNodes = [...processedData.nodes];
            let filteredLinks = [...processedData.links];
            
            // Apply network density filter
            if (networkFilters.densityMode) {
                // Calculate connection count for each node
                const connectionCounts = new Map();
                processedData.links.forEach(link => {
                    // Handle both string IDs and node object references
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source.toString();
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target.toString();
                    connectionCounts.set(sourceId, (connectionCounts.get(sourceId) || 0) + 1);
                    connectionCounts.set(targetId, (connectionCounts.get(targetId) || 0) + 1);
                });
                
                // Get top 30% most connected nodes (minimum 5 nodes)
                const sortedNodes = [...connectionCounts.entries()]
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, Math.max(5, Math.floor(connectionCounts.size * 0.3)));
                
                const highDensityNodeIds = new Set(sortedNodes.map(([nodeId]) => nodeId));
                
                filteredNodes = processedData.nodes.filter(node => highDensityNodeIds.has(node.id));
                filteredLinks = processedData.links.filter(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source.toString();
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target.toString();
                    return highDensityNodeIds.has(sourceId) && highDensityNodeIds.has(targetId);
                });
            }
            
            // Apply top expenses filter
            if (networkFilters.topExpensesMode) {
                // Sort links by value and take top 15
                const topLinks = [...filteredLinks]
                    .sort((a, b) => b.value - a.value)
                    .slice(0, 15);
                
                // Get nodes involved in top links
                const topNodeIds = new Set();
                topLinks.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source.toString();
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target.toString();
                    topNodeIds.add(sourceId);
                    topNodeIds.add(targetId);
                });
                
                filteredNodes = filteredNodes.filter(node => topNodeIds.has(node.id));
                filteredLinks = topLinks;
            }
            
            return { nodes: filteredNodes, links: filteredLinks };
        }
        
        function updateStatisticsForFilteredData(filteredData) {
            if (!window.currentAggregatedData || !filteredData) {
                console.log('Missing data for statistics update');
                return;
            }
            
            console.log('Updating statistics for filtered data - nodes:', filteredData.nodes.length, 'links:', filteredData.links.length);
            
            // Get the labels of filtered nodes for easier matching
            const filteredDeputados = new Set(
                filteredData.nodes
                    .filter(n => n.type === 'deputado')
                    .map(n => n.label)
            );
            const filteredFornecedores = new Set(
                filteredData.nodes
                    .filter(n => n.type === 'fornecedor')
                    .map(n => n.label)
            );
            
            // Filter aggregated data to only include records where BOTH deputado and fornecedor are in filtered nodes
            const filteredAggregatedData = window.currentAggregatedData.filter(record => {
                const deputadoLabel = `${record.nome_parlamentar} (${record.sigla_partido})`;
                const fornecedorLabel = record.fornecedor;
                return filteredDeputados.has(deputadoLabel) && filteredFornecedores.has(fornecedorLabel);
            });
            
            console.log('Filtered aggregated data records:', filteredAggregatedData.length);
            
            // Calculate filtered statistics
            const deputados = new Set(filteredAggregatedData.map(r => `${r.nome_parlamentar} (${r.sigla_partido})`));
            const fornecedores = new Set(filteredAggregatedData.map(r => r.fornecedor));
            const totalValue = filteredAggregatedData.reduce((sum, r) => sum + Number(r.valor_total), 0);
            const totalTransactions = filteredAggregatedData.reduce((sum, r) => sum + Number(r.num_transacoes), 0);
            
            // Update statistics display
            document.getElementById('totalDeputados').textContent = deputados.size;
            document.getElementById('totalFornecedores').textContent = fornecedores.size;
            document.getElementById('totalValue').textContent = `${totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
            document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString();
            
            console.log('Updated stats - Deputados:', deputados.size, 'Fornecedores:', fornecedores.size, 'Value:', totalValue);
            
            // Update category pie chart with filtered data
            createCategoryPieChart(filteredAggregatedData);
        }
        
        function createCategoryPieChart(data) {
            const canvas = document.getElementById('categoryPieChart');
            const legend = document.getElementById('categoryLegend');
            
            if (!canvas || !data || data.length === 0) {
                legend.innerHTML = '<div class="text-gray-500 text-center">Nenhum dado disponível</div>';
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const size = 180;
            canvas.width = size;
            canvas.height = size;
            
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2 - 10;
            
            // Calculate category totals
            const categoryTotals = new Map();
            data.forEach(record => {
                const category = record.categoria_despesa || 'Outros';
                const value = Number(record.valor_total) || 0;
                categoryTotals.set(category, (categoryTotals.get(category) || 0) + value);
            });
            
            // Convert to array and sort by value
            const categoryData = Array.from(categoryTotals.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8); // Show top 8 categories
            
            const total = categoryData.reduce((sum, [, value]) => sum + value, 0);
            if (total === 0) {
                legend.innerHTML = '<div class="text-gray-500 text-center">Nenhum dado disponível</div>';
                return;
            }
            
            // Colors for categories (same as badges)
            const colors = [
                '#3B82F6', '#10B981', '#8B5CF6', '#F59E0B', '#EC4899',
                '#6366F1', '#EF4444', '#F97316', '#14B8A6', '#06B6D4'
            ];
            
            // Clear canvas
            ctx.clearRect(0, 0, size, size);
            
            // Draw pie slices
            let currentAngle = -Math.PI / 2; // Start from top
            categoryData.forEach(([category, value], index) => {
                const sliceAngle = (value / total) * 2 * Math.PI;
                const color = colors[index % colors.length];
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                currentAngle += sliceAngle;
            });
            
            // Create legend
            const formatCurrency = (value) => `R$ ${value.toLocaleString('pt-BR')}`;
            legend.innerHTML = categoryData.map(([category, value], index) => {
                const percentage = ((value / total) * 100).toFixed(1);
                const color = colors[index % colors.length];
                const shortCategory = category;
                
                return `
                    <div class="flex items-center gap-2 py-1" title="${category}">
                        <div class="w-3 h-3 rounded-full flex-shrink-0" style="background-color: ${color}"></div>
                        <div class="flex-1 min-w-0">
                            <div class="text-xs font-medium truncate">${shortCategory}</div>
                            <div class="text-xs text-gray-500">${formatCurrency(value)} (${percentage}%)</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Global variables for chart interactivity
        let chartData = null;
        let chartTooltip = null;
        
        function createTimeSeriesChart(detailsData) {
            const canvas = document.getElementById('timeSeriesChart');
            if (!canvas || !detailsData || detailsData.length === 0) {
                showChartEmptyState(canvas);
                return;
            }
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 30;
            
            // Clear canvas with transparent background
            ctx.clearRect(0, 0, width, height);
            
            // Sort all transactions by date and filter out negative values
            const sortedData = detailsData
                .filter(item => item.data_emissao && Number(item.valor_liquido) > 0)
                .sort((a, b) => new Date(a.data_emissao) - new Date(b.data_emissao));
            
            if (sortedData.length === 0) {
                showChartEmptyState(canvas);
                return;
            }
            
            // Get date range and value range
            const firstDate = new Date(sortedData[0].data_emissao);
            const lastDate = new Date(sortedData[sortedData.length - 1].data_emissao);
            const dateRange = lastDate - firstDate || 86400000; // 1 day minimum
            
            const values = sortedData.map(item => Number(item.valor_liquido));
            const maxValue = Math.max(...values);
            const minValue = Math.min(...values);
            const valueRange = maxValue - minValue || 1;
            
            // Draw grid lines
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 2]);
            
            // Horizontal grid lines
            const gridSteps = 4;
            for (let i = 1; i <= gridSteps; i++) {
                const y = padding + (i / gridSteps) * (height - 2 * padding);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Draw axes
            ctx.strokeStyle = '#6B7280';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Y axis
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            // X axis
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Calculate bar width based on number of transactions and available space
            const availableWidth = width - 2 * padding;
            const barWidth = Math.max(1, Math.min(4, availableWidth / sortedData.length));
            
            // Store bar positions for tooltip interaction
            const barPositions = [];
            
            // Draw transaction bars with gradient and improved visuals
            sortedData.forEach((item, index) => {
                const date = new Date(item.data_emissao);
                const value = Number(item.valor_liquido);
                
                // Calculate positions
                const x = padding + ((date - firstDate) / dateRange) * (width - 2 * padding);
                const barHeight = ((value - minValue) / valueRange) * (height - 2 * padding);
                const y = height - padding - barHeight;
                
                // Store position for tooltip
                barPositions.push({
                    x: x - barWidth/2,
                    y: y,
                    width: barWidth,
                    height: barHeight,
                    data: {
                        date: item.data_emissao,
                        totalValue: value,
                        count: 1,
                        transactions: [item]
                    }
                });
                
                // Create gradient for bars based on expense category
                const categoryColor = getCategoryColor(item.categoria_despesa);
                const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                gradient.addColorStop(0, categoryColor);
                gradient.addColorStop(1, adjustColorBrightness(categoryColor, -20));
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
                
                // Add subtle shadow for depth
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetY = 1;
                ctx.fillRect(x - barWidth/2, y, barWidth, barHeight);
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
            });
            
            // Store bar positions globally for interactivity
            chartData = { sortedData, canvas, ctx, width, height, padding, barPositions };
            
            // Draw labels
            ctx.fillStyle = '#9CA3AF';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            
            // X-axis labels (first, middle, last dates)
            const formatDate = (date) => {
                return `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getFullYear()).slice(-2)}`;
            };
            
            ctx.fillText(formatDate(firstDate), padding, height - 10);
            if (dateRange > 86400000) { // More than 1 day
                const middleDate = new Date(firstDate.getTime() + dateRange / 2);
                ctx.fillText(formatDate(middleDate), width / 2, height - 10);
                ctx.fillText(formatDate(lastDate), width - padding, height - 10);
            }
            
            // Enhanced Y-axis labels
            ctx.textAlign = 'right';
            const formatCurrency = (value) => {
                if (value >= 1000000) return `R$ ${(value / 1000000).toFixed(1)}M`;
                if (value >= 1000) return `R$ ${(value / 1000).toFixed(0)}K`;
                return `R$ ${value.toFixed(0)}`;
            };
            
            // Multiple Y-axis labels along grid lines
            const labelSteps = 4;
            for (let i = 0; i <= labelSteps; i++) {
                const value = minValue + (maxValue - minValue) * (1 - i / labelSteps);
                const y = padding + (i / labelSteps) * (height - 2 * padding);
                ctx.fillText(formatCurrency(value), padding - 8, y + 3);
            }
            
            // Display summary statistics
            displaySummaryStats(sortedData);
            
            // Setup interactivity
            setupChartInteractivity(canvas);
        }
        
        function setupChartInteractivity(canvas) {
            canvas.onmousemove = handleChartHover;
            canvas.onmouseout = hideTooltip;
        }
        
        function handleChartHover(event) {
            if (!chartData || !chartData.barPositions) return;
            
            const rect = chartData.canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) * (chartData.canvas.width / rect.width);
            const y = (event.clientY - rect.top) * (chartData.canvas.height / rect.height);
            
            const hoveredBar = chartData.barPositions.find(bar => 
                x >= bar.x && x <= bar.x + bar.width && 
                y >= bar.y && y <= bar.y + bar.height
            );
            
            if (hoveredBar) {
                chartData.canvas.style.cursor = 'pointer';
                showTooltip(event, hoveredBar.data);
            } else {
                chartData.canvas.style.cursor = 'default';
                hideTooltip();
            }
        }
        
        function showTooltip(event, data) {
            hideTooltip();
            
            const tooltip = document.createElement('div');
            tooltip.style.cssText = `
                position: fixed;
                background: rgba(17, 24, 39, 0.95);
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 11px;
                pointer-events: none;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(8px);
                border: 1px solid rgba(75, 85, 99, 0.3);
                max-width: 200px;
            `;
            
            const formatCurrency = (value) => new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL', minimumFractionDigits: 2 }).format(value);
            const formatDate = (dateStr) => new Intl.DateTimeFormat('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }).format(new Date(dateStr));
            
            const transaction = data.transactions[0];
            tooltip.innerHTML = `
                <div class="font-medium text-blue-300 mb-1">${formatDate(data.date)}</div>
                <div>Valor: <span class="font-bold">${formatCurrency(data.totalValue)}</span></div>
                ${transaction.categoria_despesa ? `<div class="text-xs text-gray-300 mt-1">📋 ${transaction.categoria_despesa}</div>` : ''}
                ${transaction.fornecedor ? `<div class="text-xs text-gray-300 mt-1">→ ${transaction.fornecedor}</div>` : ''}
                ${transaction.nome_parlamentar ? `<div class="text-xs text-gray-300 mt-1">← ${transaction.nome_parlamentar}</div>` : ''}
            `;
            
            document.body.appendChild(tooltip);
            chartTooltip = tooltip;
            
            const rect = tooltip.getBoundingClientRect();
            tooltip.style.left = Math.min(event.clientX + 10, window.innerWidth - rect.width - 10) + 'px';
            tooltip.style.top = Math.max(event.clientY - rect.height - 10, 10) + 'px';
        }
        
        function hideTooltip() {
            if (chartTooltip) {
                chartTooltip.remove();
                chartTooltip = null;
            }
        }
        
        function getCategoryColor(categoria) {
            if (!categoria) return '#6B7280'; // Default gray
            
            // Hash function to generate consistent colors for categories (same as getCategoryBadge)
            const hashCode = (str) => {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash;
            };
            
            // Color palette matching the category badges (hex equivalents for dark theme)
            const colors = [
                '#3B82F6', // blue
                '#10B981', // green  
                '#8B5CF6', // purple
                '#F59E0B', // yellow
                '#EC4899', // pink
                '#6366F1', // indigo
                '#EF4444', // red
                '#F97316', // orange
                '#14B8A6', // teal
                '#06B6D4'  // cyan
            ];
            
            const colorIndex = Math.abs(hashCode(categoria)) % colors.length;
            return colors[colorIndex];
        }
        
        function adjustColorBrightness(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
        }
        
        function showChartEmptyState(canvas) {
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.clearRect(0, 0, width, height);
            
            // Draw empty state with icon
            ctx.fillStyle = '#6B7280';
            ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('📊', width / 2, height / 2 - 20);
            
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.fillStyle = '#9CA3AF';
            ctx.fillText('Nenhum dado temporal disponível', width / 2, height / 2 + 10);
            ctx.fillText('Transações sem data válida', width / 2, height / 2 + 25);
        }
        
        function displaySummaryStats(transactionData) {
            const totalValue = transactionData.reduce((sum, item) => sum + Number(item.valor_liquido), 0);
            const avgValue = totalValue / transactionData.length;
            const maxTransaction = Math.max(...transactionData.map(item => Number(item.valor_liquido)));
            
            // Find the chart container and add stats
            const chartContainer = document.querySelector('#timeSeriesChart').parentElement;
            let statsDiv = chartContainer.querySelector('.chart-stats');
            
            if (!statsDiv) {
                statsDiv = document.createElement('div');
                statsDiv.className = 'chart-stats text-xs text-gray-400 mb-2 flex justify-between';
                chartContainer.insertBefore(statsDiv, chartContainer.firstChild);
            }
            
            const formatCurrency = (value) => {
                return new Intl.NumberFormat('pt-BR', {
                    style: 'currency',
                    currency: 'BRL',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(value);
            };
            
            statsDiv.innerHTML = `
                <div>Total: <span class="text-white font-medium">${formatCurrency(totalValue)}</span></div>
                <div>Média: <span class="text-white font-medium">${formatCurrency(avgValue)}</span></div>
                <div>Maior: <span class="text-white font-medium">${formatCurrency(maxTransaction)}</span></div>
            `;
        }
        
        function initializeVisualization() {
            // Clear loading message
            const loadingEl = document.querySelector('#loading');
            if (loadingEl) loadingEl.style.display = 'none';
            
            // Apply network filters and get filtered data
            const filteredData = applyNetworkFilters();
            
            // Update statistics based on filtered data
            if (networkFilters.densityMode || networkFilters.topExpensesMode) {
                updateStatisticsForFilteredData(filteredData);
            } else if (window.currentAggregatedData) {
                // Restore original statistics when no network filters are active
                const deputados = new Set(window.currentAggregatedData.map(r => `${r.nome_parlamentar} (${r.sigla_partido})`));
                const fornecedores = new Set(window.currentAggregatedData.map(r => r.fornecedor));
                const totalValue = window.currentAggregatedData.reduce((sum, r) => sum + Number(r.valor_total), 0);
                const totalTransactions = window.currentAggregatedData.reduce((sum, r) => sum + Number(r.num_transacoes), 0);
                
                document.getElementById('totalDeputados').textContent = deputados.size;
                document.getElementById('totalFornecedores').textContent = fornecedores.size;
                document.getElementById('totalValue').textContent = `${totalValue.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
                document.getElementById('totalTransactions').textContent = totalTransactions.toLocaleString();
                
                createCategoryPieChart(window.currentAggregatedData);
            }
            
            // Check if we have data to visualize
            if (!filteredData.nodes || filteredData.nodes.length === 0) {
                console.log('Nenhum dado para visualizar');
                if (loadingEl) {
                    loadingEl.style.display = 'flex';
                    loadingEl.innerHTML = 'Nenhum dado encontrado com os filtros aplicados';
                }
                return;
            }
            
            console.log('🎨 Criando visualização D3.js...');
            
            const svg = d3.select("#network-svg");
            const container = svg.node().parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            svg.attr("width", width).attr("height", height);
            svg.selectAll("*").remove(); // Clear previous content
            
            // Add zoom behavior with mouse wheel
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .wheelDelta((event) => -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002))
                .on("zoom", (event) => {
                    g.attr("transform", event.transform);
                });
            
            svg.call(zoom)
                .on("dblclick.zoom", null) // Disable double-click zoom
                .on("click", (event) => {
                    // Only hide panel if clicking on the background (not on nodes)
                    if (event.target === event.currentTarget) {
                        hideNodeInfo();
                    }
                });
            
            // Create main group for zooming/panning
            const g = svg.append("g");
            
            // Prepare data for D3
            const nodes = filteredData.nodes.map(d => ({
                ...d,
                id: d.id,
                x: Math.random() * width,
                y: Math.random() * height
            }));
            
            const links = filteredData.links.map(d => ({
                ...d,
                source: d.source,
                target: d.target
            }));
            
            console.log(`Creating D3 visualization: ${nodes.length} nodes, ${links.length} links`);
            
            // Function to calculate node radius
            const getNodeRadius = (d) => {
                return d.type === 'deputado' ? 8 : 6;
            };
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(50))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide().radius(10));
            
            // Add links
            const link = g.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.4)
                .attr("stroke-width", 0.5);

            // Add nodes
            const searchFilter = document.getElementById('searchBox').value.trim().toLowerCase();
            const node = g.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", getNodeRadius)
                .attr("fill", d => {
                    // Highlight matching search results
                    if (searchFilter && d.label.toLowerCase().includes(searchFilter)) {
                        return d.type === 'deputado' ? '#fbbf24' : '#6ee7b7'; // Gold and mint highlights
                    }
                    return d.type === 'deputado' ? '#3b82f6' : 'rgb(196, 82, 17)';
                })
                .attr("stroke", d => {
                    // Special stroke for search matches
                    if (searchFilter && d.label.toLowerCase().includes(searchFilter)) {
                        return "#fff";
                    }
                    return "#fff";
                })
                .attr("stroke-width", d => {
                    // Thicker stroke for search matches
                    if (searchFilter && d.label.toLowerCase().includes(searchFilter)) {
                        return 3;
                    }
                    return 1.5;
                })
                .style("cursor", "pointer")
                .on("click", (event, d) => {
                    event.stopPropagation();
                    showNodeInfo(d);
                })
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));
            
            // Add labels for nodes
            const label = g.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .text(d => {
                    if (d.type === 'deputado') {
                        const words = d.label.split(' ');
                        // Get first two words for deputies
                        return words.slice(0, 2).join(' ');
                    } else {
                        // Don't show company names by default
                        return '';
                    }
                })
                .attr("font-size", d => d.type === 'deputado' ? "10px" : "8px")
                .attr("fill", d => d.type === 'deputado' ? "white" : "rgb(196, 82, 17)")
                .attr("text-anchor", "middle")
                .attr("dy", 20)
                .attr("class", "node-label");
            
            // Add edge labels for spending amounts
            const formatCurrency = (value) => {
                if (value >= 1000000) return `R$ ${(value/1000000).toFixed(1)}M`;
                if (value >= 1000) return `R$ ${(value/1000).toFixed(0)}K`;
                return `R$ ${value.toFixed(0)}`;
            };
            
            // Create edge labels (initially hidden)
            const edgeLabels = g.append("g")
                .selectAll("text")
                .data(links)
                .enter().append("text")
                .text(d => formatCurrency(d.value))
                .attr("font-size", "6px")
                .attr("fill", "#ffd93d")
                .attr("text-anchor", "middle")
                .attr("dy", 3)
                .style("pointer-events", "none")
                .style("opacity", 0)
                .style("display", "none");
            
            // Update positions on tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                label
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
                
                // Position edge labels at link midpoints
                edgeLabels
                    .attr("x", d => (d.source.x + d.target.x) / 2)
                    .attr("y", d => (d.source.y + d.target.y) / 2);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Zoom button controls
            const fitToView = () => {
                try {
                    const bounds = g.node().getBBox();
                    const fullWidth = bounds.width;
                    const fullHeight = bounds.height;
                    const centerX = bounds.x + fullWidth / 2;
                    const centerY = bounds.y + fullHeight / 2;
                    
                    // Check for invalid values
                    if (!isFinite(fullWidth) || !isFinite(fullHeight) || fullWidth <= 0 || fullHeight <= 0) {
                        console.warn('Invalid bounds for fit to view, skipping');
                        return;
                    }
                    
                    const scale = Math.min(width / fullWidth, height / fullHeight) * 0.8;
                    const translate = [width / 2 - scale * centerX, height / 2 - scale * centerY];
                    
                    // Check for NaN values in transform
                    if (!isFinite(translate[0]) || !isFinite(translate[1]) || !isFinite(scale)) {
                        console.warn('Invalid transform values, skipping fit to view');
                        return;
                    }
                    
                    svg.transition()
                        .duration(750)
                        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                } catch (error) {
                    console.warn('Error in fitToView:', error);
                }
            };
            
            // Zoom controls
            d3.select("#zoom-in").on("click", () => {
                svg.transition().duration(300).call(zoom.scaleBy, 1.5);
            });
            
            d3.select("#zoom-out").on("click", () => {
                svg.transition().duration(300).call(zoom.scaleBy, 1 / 1.5);
            });
            
            d3.select("#zoom-reset").on("click", fitToView);
            
            // Initial zoom out to show full network
            setTimeout(fitToView, 2000);
            
            console.log('✅ D3.js visualization created successfully!');
            
            // Store references for updating labels
            window.currentVisualization = { label, nodes, edgeLabels };
        }
        
        function updateCompanyLabels(showNames) {
            if (window.currentVisualization && window.currentVisualization.label) {
                window.currentVisualization.label.text(d => {
                    if (d.type === 'deputado') {
                        const words = d.label.split(' ');
                        return words.slice(0, 2).join(' ');
                    } else {
                        return showNames ? d.label : '';
                    }
                })
                .attr("font-size", d => d.type === 'deputado' ? "10px" : "8px")
                .attr("fill", d => d.type === 'deputado' ? "white" : "rgb(196, 82, 17)");
            }
        }
        
        function updateEdgeAmounts(showAmounts) {
            if (window.currentVisualization && window.currentVisualization.edgeLabels) {
                if (showAmounts) {
                    // Show edge labels with fade-in effect
                    window.currentVisualization.edgeLabels
                        .style("display", "block")
                        .transition()
                        .duration(300)
                        .style("opacity", 0.8);
                } else {
                    // Hide edge labels with fade-out effect
                    window.currentVisualization.edgeLabels
                        .transition()
                        .duration(300)
                        .style("opacity", 0)
                        .on("end", function() {
                            d3.select(this).style("display", "none");
                        });
                }
            }
        }
        
        
        async function showNodeInfo(nodeData) {
            const content = document.getElementById('node-info-content');
            const closeBtn = document.getElementById('close-panel');
            const rightPanel = document.getElementById('right-panel');
            
            // Reset all nodes to normal appearance first
            const svg = d3.select('#network-svg');
            const searchFilter = document.getElementById('searchBox').value.trim().toLowerCase();
            svg.selectAll('circle')
                .attr("stroke-width", d => {
                    // Keep search highlights if they exist
                    return (searchFilter && d.label.toLowerCase().includes(searchFilter)) ? 3 : 1.5;
                })
                .attr("stroke", d => {
                    // Reset to normal stroke colors
                    if (searchFilter && d.label.toLowerCase().includes(searchFilter)) {
                        return "#fff"; // Keep white stroke for search matches
                    }
                    return "#fff"; // Normal white stroke
                })
                .attr("r", d => d.type === 'deputado' ? 8 : 6); // Reset to normal radius
            
            // Highlight the selected node
            svg.selectAll('circle')
                .filter(d => d.id === nodeData.id)
                .attr("stroke-width", 4)
                .attr("stroke", "#FFD700") // Gold highlight for selection
                .attr("r", d => (d.type === 'deputado' ? 8 : 6) + 2); // Slightly larger
            
            // Slide in the right panel
            rightPanel.classList.remove('translate-x-full');
            
            // Show loading state
            content.innerHTML = '<div class="flex items-center gap-2 text-gray-400"><div class="loading-spinner"></div>Carregando detalhes...</div>';
            content.style.display = 'block';
            content.className = 'p-4 flex flex-col flex-1 min-h-0';
            closeBtn.classList.remove('hidden');
            
            try {
                // Query detailed transactions for this entity
                const detailsData = await getEntityDetails(nodeData);
                
                // Create details content
                const formatCurrency = (value) => `R$ ${value.toLocaleString('pt-BR', { minimumFractionDigits: 2 })}`;
                const formatNumber = (value) => value.toLocaleString('pt-BR');
                const formatDate = (dateStr) => {
                    if (!dateStr) return 'N/A';
                    try {
                        const date = new Date(dateStr);
                        return date.toLocaleDateString('pt-BR');
                    } catch {
                        return dateStr;
                    }
                };
                
                const getCategoryBadge = (categoria) => {
                    if (!categoria) return '';
                    
                    // Hash function to generate consistent colors for categories
                    const hashCode = (str) => {
                        let hash = 0;
                        for (let i = 0; i < str.length; i++) {
                            const char = str.charCodeAt(i);
                            hash = ((hash << 5) - hash) + char;
                            hash = hash & hash; // Convert to 32-bit integer
                        }
                        return hash;
                    };
                    
                    const colors = [
                        { bg: 'bg-blue-100 dark:bg-blue-900', text: 'text-blue-800 dark:text-blue-200' },
                        { bg: 'bg-green-100 dark:bg-green-900', text: 'text-green-800 dark:text-green-200' },
                        { bg: 'bg-purple-100 dark:bg-purple-900', text: 'text-purple-800 dark:text-purple-200' },
                        { bg: 'bg-yellow-100 dark:bg-yellow-900', text: 'text-yellow-800 dark:text-yellow-200' },
                        { bg: 'bg-pink-100 dark:bg-pink-900', text: 'text-pink-800 dark:text-pink-200' },
                        { bg: 'bg-indigo-100 dark:bg-indigo-900', text: 'text-indigo-800 dark:text-indigo-200' },
                        { bg: 'bg-red-100 dark:bg-red-900', text: 'text-red-800 dark:text-red-200' },
                        { bg: 'bg-orange-100 dark:bg-orange-900', text: 'text-orange-800 dark:text-orange-200' },
                        { bg: 'bg-teal-100 dark:bg-teal-900', text: 'text-teal-800 dark:text-teal-200' },
                        { bg: 'bg-cyan-100 dark:bg-cyan-900', text: 'text-cyan-800 dark:text-cyan-200' }
                    ];
                    
                    const colorIndex = Math.abs(hashCode(categoria)) % colors.length;
                    const color = colors[colorIndex];
                    
                    return `<span class="inline-flex items-center gap-1 px-1.5 py-0.5 rounded font-light ${color.bg} ${color.text}" style="font-size: 8px;" title="${categoria}"><span class="w-1 h-1 rounded-full bg-current"></span>${categoria}</span>`;
                };
                
                let contentHTML = '';
                
                if (nodeData.type === 'deputado') {
                    const totalTransactions = detailsData.length;
                    const totalValue = detailsData.reduce((sum, item) => sum + Number(item.valor_liquido), 0);
                    
                    contentHTML = `
                        <div class="pb-3 border-b border-gray-600 mb-3">
                            <h4 class="text-base font-bold text-deputy mb-1">${nodeData.label}</h4>
                            <div class="flex justify-between items-center text-xs text-gray-400 mb-1">
                                <span>Gastou • ${formatCurrency(totalValue)}</span>
                            </div>
                            <br/>
                            <div class="text-xs text-gray-400">TRANSAÇÕES (${formatNumber(totalTransactions)})</div>
                        </div>
                        <div class="flex-1 flex flex-col min-h-0">
                            <!-- Time Series Chart -->
                            <div class="mb-3">
                                <div class="bg-gray-800 rounded p-3">
                                    <canvas id="timeSeriesChart" width="280" height="120" class="w-full"></canvas>
                                </div>
                            </div>
                            
                            <div class="node-info-scroll-container space-y-2 enhanced-scroll smooth-scroll">
                                ${detailsData.map(item => `
                                    <div class="transaction-card bg-gray-800/50 backdrop-blur-sm border border-gray-600/30 rounded-lg p-3 hover:bg-gray-700/70 hover:border-gray-500/50 transition-all duration-200 cursor-pointer shadow-sm hover:shadow-md border-l-4 border-l-supplier" onclick="highlightNodeInVisualization('${item.fornecedor.replace(/'/g, "\\'")}', 'fornecedor')">
                                        <!-- Line 1: Name -->
                                        <div class="flex items-center gap-2 mb-2">
                                            <div class="font-semibold text-supplier text-sm truncate flex-1" title="${item.fornecedor}">→ ${item.fornecedor}</div>
                                        </div>
                                        
                                        <!-- Line 2: Value + Date -->
                                        <div class="flex justify-between items-center mb-2">
                                            <div class="font-bold text-xs">${formatCurrency(item.valor_liquido)}</div>
                                            <div class="flex items-center gap-1 text-xs text-gray-400">
                                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                                                </svg>
                                                ${formatDate(item.data_emissao)}
                                            </div>
                                        </div>
                                        
                                        <!-- Line 3: Category Badge -->
                                        <div class="flex gap-1 truncate">
                                            ${getCategoryBadge(item.categoria_despesa)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                } else {
                    const totalTransactions = detailsData.length;
                    const totalValue = detailsData.reduce((sum, item) => sum + Number(item.valor_liquido), 0);
                    
                    contentHTML = `
                        <div class="pb-3 border-b border-gray-600 mb-3">
                            <h4 class="text-base font-bold text-supplier mb-1">${nodeData.label}</h4>
                            <div class="flex justify-between items-center text-xs text-gray-400 mb-1">
                                <span>Recebeu • ${formatCurrency(totalValue)}</span>
                            </div>
                            <br/>
                            <div class="text-xs text-gray-400">TRANSAÇÕES (${formatNumber(totalTransactions)})</div>
                        </div>
                        <div class="flex-1 flex flex-col min-h-0">
                            <!-- Time Series Chart -->
                            <div class="mb-3">
                                <div class="bg-gray-800 rounded p-3">
                                    <canvas id="timeSeriesChart" width="280" height="120" class="w-full"></canvas>
                                </div>
                            </div>
                            
                            <div class="node-info-scroll-container space-y-2 enhanced-scroll smooth-scroll">
                                ${detailsData.map(item => `
                                    <div class="transaction-card bg-gray-800/50 backdrop-blur-sm border border-gray-600/30 rounded-lg p-3 hover:bg-gray-700/70 hover:border-gray-500/50 transition-all duration-200 cursor-pointer shadow-sm hover:shadow-md border-l-4 border-l-deputy" onclick="highlightNodeInVisualization('${item.nome_parlamentar.replace(/'/g, "\\'")}', 'deputado')">
                                        <!-- Line 1: Name + Party -->
                                        <div class="flex items-center gap-2 mb-2">
                                            <div class="font-semibold text-deputy text-sm truncate flex-1">← ${item.nome_parlamentar} • ${item.sigla_partido}</div>
                                        </div>
                                        
                                        <!-- Line 2: Value + Date -->
                                        <div class="flex justify-between items-center mb-2">
                                            <div class="font-bold text-sm">${formatCurrency(item.valor_liquido)}</div>
                                            <div class="flex items-center gap-1 text-xs text-gray-400">
                                                <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd"></path>
                                                </svg>
                                                ${formatDate(item.data_emissao)}
                                            </div>
                                        </div>
                                        
                                        <!-- Line 3: Category Badge -->
                                        <div class="flex gap-1 truncate">
                                            ${getCategoryBadge(item.categoria_despesa)}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                
                content.innerHTML = contentHTML;
                
                // Create time series chart after content is set
                setTimeout(() => {
                    createTimeSeriesChart(detailsData);
                }, 50);
                
            } catch (error) {
                console.error('Erro ao carregar detalhes:', error);
                content.innerHTML = `<div class="text-red-400 text-sm">Erro ao carregar detalhes: ${error.message}</div>`;
            }
        }
        
        async function getEntityDetails(nodeData) {
            // Query to get detailed transactions for the selected entity
            let query = '';
            let entityName = '';
            
            if (nodeData.type === 'deputado') {
                entityName = nodeData.label.replace(/\([^)]*\)/, '').trim(); // Remove party from label
                query = `
                    SELECT 
                        fornecedor,
                        data_emissao,
                        valor_liquido,
                        categoria_despesa,
                        subcategoria_despesa
                    FROM despesas 
                    WHERE nome_parlamentar = '${entityName}'
                    ORDER BY data_emissao DESC, valor_liquido DESC
                    LIMIT 200
                `;
            } else {
                entityName = nodeData.label;
                query = `
                    SELECT 
                        nome_parlamentar,
                        sigla_partido,
                        data_emissao,
                        valor_liquido,
                        categoria_despesa,
                        subcategoria_despesa
                    FROM despesas 
                    WHERE fornecedor = '${entityName}'
                    ORDER BY data_emissao DESC, valor_liquido DESC
                    LIMIT 200
                `;
            }
            
            console.log('🔍 Executing entity details query:', query);
            const result = await window.duckdbAPI.query(query);
            return result.toArray();
        }
        
        function highlightNodeInVisualization(entityName, entityType) {
            if (!window.currentVisualization) return;
            
            // Find the target node
            const targetNode = window.currentVisualization.nodes.find(node => {
                if (entityType === 'fornecedor') {
                    return node.type === 'fornecedor' && node.label === entityName;
                } else {
                    // For deputado, match name with or without party
                    return node.type === 'deputado' && (
                        node.label.includes(entityName) || 
                        entityName.includes(node.label.split('(')[0].trim())
                    );
                }
            });
            
            if (!targetNode) return;
            
            // Get the current D3 selection for nodes
            const svg = d3.select("#network-svg");
            const nodes = svg.selectAll("circle");
            
            // Reset all nodes to normal appearance
            nodes
                .attr("stroke-width", d => {
                    const searchFilter = document.getElementById('searchBox').value.trim().toLowerCase();
                    return (searchFilter && d.label.toLowerCase().includes(searchFilter)) ? 3 : 1.5;
                })
                .attr("stroke", "#fff") // Reset stroke color to default white
                .attr("r", d => d.type === 'deputado' ? 8 : 6);
            
            // Highlight the target node
            nodes
                .filter(d => d.id === targetNode.id)
                .attr("stroke-width", 4)
                .attr("stroke", "#FFD700") // Gold highlight
                .attr("r", d => (d.type === 'deputado' ? 8 : 6) + 2);
            
            // Smooth pan to the node
            const transform = d3.zoomTransform(svg.node());
            const x = targetNode.x;
            const y = targetNode.y;
            
            // Check for valid coordinates
            if (!isFinite(x) || !isFinite(y)) {
                console.warn('Node has invalid coordinates, skipping pan');
                return;
            }
            
            const scale = Math.max(transform.k, 1.5); // Ensure minimum zoom level
            
            const containerRect = svg.node().getBoundingClientRect();
            const centerX = containerRect.width / 2;
            const centerY = containerRect.height / 2;
            
            const translateX = centerX - scale * x;
            const translateY = centerY - scale * y;
            
            // Check for valid transform values
            if (!isFinite(translateX) || !isFinite(translateY) || !isFinite(scale)) {
                console.warn('Invalid transform values in highlight, skipping pan');
                return;
            }
            
            const newTransform = d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(scale);
            
            svg.transition()
                .duration(800)
                .call(d3.zoom().transform, newTransform);
        }
        
        function hideNodeInfo() {
            const rightPanel = document.getElementById('right-panel');
            const content = document.getElementById('node-info-content');
            const closeBtn = document.getElementById('close-panel');
            
            // Reset all nodes to normal appearance when hiding panel
            const svg = d3.select('#network-svg');
            const searchFilter = document.getElementById('searchBox').value.trim().toLowerCase();
            svg.selectAll('circle')
                .attr("stroke-width", d => {
                    // Keep search highlights if they exist
                    return (searchFilter && d.label.toLowerCase().includes(searchFilter)) ? 3 : 1.5;
                })
                .attr("stroke", d => {
                    // Reset to normal stroke colors
                    if (searchFilter && d.label.toLowerCase().includes(searchFilter)) {
                        return "#fff"; // Keep white stroke for search matches
                    }
                    return "#fff"; // Normal white stroke
                })
                .attr("r", d => d.type === 'deputado' ? 8 : 6); // Reset to normal radius
            
            // Slide out the right panel
            rightPanel.classList.add('translate-x-full');
            
            // Reset content after animation completes
            setTimeout(() => {
                content.innerHTML = '<p class="text-xs text-gray-500 dark:text-gray-400">Clique em um nó para ver detalhes</p>';
                content.className = 'p-4 flex flex-col flex-1 min-h-0';
                closeBtn.classList.add('hidden');
            }, 300);
        }
        
        async function updateVisualization() {
            await processData();
            initializeVisualization();
        }
        
        function setupEventListeners() {
            // Update slider display
            const minValueSlider = document.getElementById('minValue');
            const minValueDisplay = document.getElementById('minValueValue');
            const partyFilter = document.getElementById('partyFilter');
            const categoryFilter = document.getElementById('categoryFilter');
            const showCompanyNames = document.getElementById('showCompanyNames');
            const searchBox = document.getElementById('searchBox');
            const clearSearch = document.getElementById('clearSearch');
            
            function updateSliderDisplay() {
                const value = parseInt(minValueSlider.value);
                const formatValue = (val) => {
                    if (val >= 1000000) return `${(val/1000000).toFixed(1)}M`;
                    if (val >= 1000) return `${(val/1000).toFixed(0)}K`;
                    return val.toLocaleString('pt-BR');
                };
                minValueDisplay.textContent = formatValue(value);
            }
            
            // Auto-update with debounce for slider
            let sliderTimeout;
            minValueSlider.addEventListener('input', () => {
                updateSliderDisplay();
                clearTimeout(sliderTimeout);
                sliderTimeout = setTimeout(() => {
                    updateVisualization();
                }, 500); // 500ms debounce
            });
            
            // Function to reset min/max slider
            function resetSliderRange() {
                const slider = document.getElementById('minValue');
                slider.value = 0;
                slider.min = 0;
                slider.max = 100000;
                document.getElementById('minRange').textContent = 'Min: R$ 0';
                document.getElementById('maxRange').textContent = 'Max: R$ 100.000';
                updateSliderDisplay();
            }

            // Auto-update immediately for select boxes with slider reset
            partyFilter.addEventListener('change', () => {
                resetSliderRange();
                updateVisualization();
            });
            categoryFilter.addEventListener('change', () => {
                resetSliderRange();
                updateVisualization();
            });
            
            // Search functionality with debounce
            let searchTimeout;
            searchBox.addEventListener('input', (e) => {
                const value = e.target.value.trim();
                
                // Show/hide clear button
                if (value) {
                    clearSearch.classList.remove('hidden');
                } else {
                    clearSearch.classList.add('hidden');
                }
                
                // Update visualization with debounce
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    updateVisualization();
                }, 300); // 300ms debounce for search
            });
            
            // Clear search button
            clearSearch.addEventListener('click', () => {
                searchBox.value = '';
                clearSearch.classList.add('hidden');
                updateVisualization();
            });
            
            // Clear search on Escape key
            searchBox.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    searchBox.value = '';
                    clearSearch.classList.add('hidden');
                    updateVisualization();
                }
            });
            
            // Handle company names checkbox
            showCompanyNames.addEventListener('change', (e) => {
                updateCompanyLabels(e.target.checked);
            });
            
            // Handle edge amounts checkbox
            const showEdgeAmounts = document.getElementById('showEdgeAmounts');
            showEdgeAmounts.addEventListener('change', (e) => {
                updateEdgeAmounts(e.target.checked);
            });
            
            updateSliderDisplay();
            
            // Network analysis toggle switches
            const networkDensityToggle = document.getElementById('networkDensityToggle');
            const topExpensesToggle = document.getElementById('topExpensesToggle');
            
            networkDensityToggle.addEventListener('change', () => {
                networkFilters.densityMode = networkDensityToggle.checked;
                initializeVisualization();
            });
            
            topExpensesToggle.addEventListener('change', () => {
                networkFilters.topExpensesMode = topExpensesToggle.checked;
                initializeVisualization();
            });
            
            // Close panel
            document.getElementById('close-panel').addEventListener('click', () => {
                hideNodeInfo();
            });
        }
        
        // Add dark mode toggle functionality
        function setupThemeToggle() {
            const themeToggle = document.getElementById('theme-toggle');
            const html = document.documentElement;
            
            if (themeToggle) {
                themeToggle.addEventListener('click', () => {
                if (html.classList.contains('dark')) {
                    html.classList.remove('dark');
                    themeToggle.textContent = '🌞';
                    document.body.className = 'font-sans bg-white text-gray-900 h-screen overflow-hidden';
                } else {
                    html.classList.add('dark');
                    themeToggle.textContent = '🌙';
                    document.body.className = 'font-sans bg-white dark:bg-gray-950 text-gray-900 dark:text-white h-screen overflow-hidden';
                }
                });
            }
        }
        
        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Setup theme toggle first
            setupThemeToggle();
            
            // Then load data
            loadData().catch(error => {
                console.error('Failed to load data:', error);
                updateConnectionStatus('error', 'Falha na inicialização');
            });
        });
        
    </script>
</body>
</html>